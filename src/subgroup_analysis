# 1. 准备用于分析和绘图的DataFrame
# 我们将所有计算出的性别重要性DataFrame合并到一个大表中
all_sex_importance_list = []
for sex_label, importance_df in sex_importance_dfs.items():
    # 只要 sex_importance_dfs 中存在这个群体，就将其加入列表
    temp_df = importance_df.copy()
    temp_df['Group'] = sex_label
    all_sex_importance_list.append(temp_df)

# 检查列表是否为空
if not all_sex_importance_list:
    print("\nNo gender groups with sufficient data were found in the test set to analyze.")
else:
    # 合并成一个大的DataFrame
    all_sex_importance_df = pd.concat(all_sex_importance_list)

    # --- 修改后的代码：生成宽格式的特征重要性对比表 ---
    print("\n" + "="*80)
    print("--- Feature Importance Comparison Table (Wide Format) ---")
    print("="*80 + "\n")

    # 1. 使用 pivot_table 将长格式数据转换为宽格式
    wide_format_table = all_sex_importance_df.pivot_table(
        index='Feature',
        columns='Group',
        values='Mean_Absolute_SHAP'
    )

    # 2. 按总体重要性对特征进行排序，使最重要的特征显示在顶部
    overall_importance = wide_format_table.mean(axis=1)
    wide_format_table = wide_format_table.loc[overall_importance.sort_values(ascending=False).index]
    
    # 3. 打印完整的表格
    print(wide_format_table.to_string())



    # --- 可视化部分（保持不变） ---

    # 2. 确定要展示的特征 (用于绘图)
    # 为了图表整洁，我们选取在所有群体中，平均重要性排名前15的特征
    top_features_for_plot = all_sex_importance_df.groupby('Feature')['Mean_Absolute_SHAP'].mean().nlargest(15).index
    
    # 筛选出只包含这些顶级特征的数据
    plot_df_all_groups = all_sex_importance_df[all_sex_importance_df['Feature'].isin(top_features_for_plot)]
    
    # 3. 使用 seaborn.catplot 进行可视化
    g = sns.catplot(
        x='Mean_Absolute_SHAP',
        y='Feature',
        col='Group',  # 关键参数：为每个组创建一个列
        data=plot_df_all_groups,
        kind='bar',
        height=8,     # 控制每个子图的高度
        aspect=0.6,   # 控制每个子图的宽高比
        palette='viridis',
        orient='h',
        order=top_features_for_plot.tolist() # 确保所有子图的y轴顺序一致
    )
    
    # 调整全局标题和坐标轴
    g.fig.suptitle('Feature Importance Comparison Across All Available Gender Groups (Top 15 Features)', y=1.03, fontsize=16)
    g.set_axis_labels('Mean Absolute SHAP Value (Importance)', 'Feature')
    g.set_titles("Group: {col_name}") # 设置每个子图的标题
    
    # 自动调整布局
    plt.tight_layout()
    plt.show()



# =========================================================================
# --- 年龄组分析：生成综合表格与可视化图表 ---
# =========================================================================

# --- 计算部分（保持不变） ---
# 年龄组标签 (使用.dropna()确保我们只处理测试集中实际存在的年龄组)
age_group_labels = sorted(analysis_df['age_group_stratify'].dropna().unique().astype(str))

# 存储每个年龄组的特征重要性
age_importance_dfs = {}

for group_label in age_group_labels:
    group_indices = analysis_df[analysis_df['age_group_stratify'] == group_label].index
    if len(group_indices) == 0:
        continue
    group_shap_values = shap_df.loc[group_indices]
    mean_abs_shap_group = group_shap_values.abs().mean(axis=0)
    group_importance_df = pd.DataFrame({
        'Feature': X_test.columns,
        'Mean_Absolute_SHAP': mean_abs_shap_group
    }).sort_values(by='Mean_Absolute_SHAP', ascending=False).reset_index(drop=True)
    age_importance_dfs[group_label] = group_importance_df
    
# --- 数据整合与制表部分 ---
all_age_importance_list = []
for group_label, importance_df in age_importance_dfs.items():
    temp_df = importance_df.copy()
    temp_df['Group'] = group_label
    all_age_importance_list.append(temp_df)

if not all_age_importance_list:
    print("\nNo age groups with sufficient data were found in the test set to analyze.")
else:
    # 合并成一个大的长格式DataFrame
    all_age_importance_df = pd.concat(all_age_importance_list)

    # 1. 生成宽格式的特征重要性对比表
    print("\n" + "="*80)
    print("--- Age Group Feature Importance Comparison Table (Wide Format) ---")
    print("="*80 + "\n")

    wide_format_age_table = all_age_importance_df.pivot_table(
        index='Feature',
        columns='Group',
        values='Mean_Absolute_SHAP'
    )
    # 按总体重要性排序
    overall_age_importance = wide_format_age_table.mean(axis=1)
    wide_format_age_table = wide_format_age_table.loc[overall_age_importance.sort_values(ascending=False).index]
    
    # 打印完整的表格
    print(wide_format_age_table.to_string())
    

    # --- 可视化部分 ---
    
    # 2. 确定用于绘图的Top 15特征
    top_features_for_age_plot = all_age_importance_df.groupby('Feature')['Mean_Absolute_SHAP'].mean().nlargest(15).index
    
    # 筛选绘图所需数据
    plot_df_all_age_groups = all_age_importance_df[all_age_importance_df['Feature'].isin(top_features_for_age_plot)]
    
    # 3. 使用 seaborn.catplot 进行可视化
    g_age = sns.catplot(
        x='Mean_Absolute_SHAP',
        y='Feature',
        col='Group',  # 为每个年龄组创建一个子图列
        data=plot_df_all_age_groups,
        kind='bar',
        height=8,
        aspect=0.6,
        palette='magma', # 使用一个适合连续变化的调色板
        orient='h',
        col_order=age_group_labels, # 确保子图按年龄顺序排列
        order=top_features_for_age_plot.tolist() # 确保所有子图的y轴顺序一致
    )
    
    # 调整全局标题和坐标轴
    g_age.fig.suptitle('Feature Importance Comparison Across All Available Age Groups (Top 15 Features)', y=1.03, fontsize=16)
    g_age.set_axis_labels('Mean Absolute SHAP Value (Importance)', 'Feature')
    g_age.set_titles("Age Group: {col_name}")
    
    # 自动调整布局
    plt.tight_layout()
    plt.show()
-------------------------------------------------------------------------------------

# 准备 X_test_grouped，添加分组信息
X_test_grouped = X_test.copy()
# 确保使用原始DataFrame的索引来安全地匹配分组信息
X_test_grouped['sex'] = df.loc[X_test.index, 'sex'] # 假设原始列名为 'sex'
X_test_grouped['age_group'] = df.loc[X_test.index, 'age_group_stratify']

# 为了MLR模型，准备一个带有常数项的测试集
X_test_sm = sm.add_constant(X_test)

# --- 2. 定义模型字典，方便循环 ---
# 将模型和它们的名称存储在一个字典中
models = {
    "MLR": mlr_model,
    "Random Forest": rf_model,
    "XGBoost": xgb_model
}
# 使用原始的数值编码进行筛选，标签仅用于最终表格
gender_groups_map = {1: 'Male', 2: 'Female', 3: 'Other'}
age_groups = sorted(X_test_grouped['age_group'].unique().tolist())

# --- 4. 循环遍历模型和子组，计算性能 ---
performance_results = []

# 外层循环：遍历每一个模型
for model_name, model in models.items():
    print(f"--- Evaluating Model: {model_name} ---")

    # 定义所有要评估的分组
    # 性别分组
    gender_subgroups = [
        (('Gender', label), (X_test_grouped['sex'] == code))
        for code, label in gender_groups_map.items()
    ]
    # 年龄分组
    age_subgroups = [
        (('Age', label), (X_test_grouped['age_group'] == label))
        for label in age_groups
    ]
    all_groups = gender_subgroups + age_subgroups

    for (group_type, group_name), subgroup_filter in all_groups:

        X_test_sub = X_test_grouped[subgroup_filter]
        y_test_sub = y_test[subgroup_filter]

        if len(X_test_sub) > 0:
            if model_name == "MLR":
                X_test_sub_features = X_test_sub[X_train.columns]
                X_test_sub_final = sm.add_constant(X_test_sub_features, has_constant='add')
                y_pred_sub = model.predict(X_test_sub_final)
            else:
                X_test_sub_features = X_test_sub[X_features]
                y_pred_sub = model.predict(X_test_sub_features)

            mse = mean_squared_error(y_test_sub, y_pred_sub)
            r2 = r2_score(y_test_sub, y_pred_sub)

            performance_results.append({
                'Model': model_name,
                'Group Type': group_type,
                'Group Name': group_name,
                'N_Samples': len(X_test_sub),
                'MSE': mse,
                'R2': r2
            })

# --- 5. 将结果转换为一个清晰的、合并了 MSE 和 R2 的表格 ---
performance_df = pd.DataFrame(performance_results)

print("\n--- Combined Performance Summary Table (MSE and R2) ---")

# 使用 set_index 和 unstack 来创建多层列表格
performance_pivot = performance_df.set_index(['Group Type', 'Group Name', 'N_Samples', 'Model'])\
                                  .unstack('Model') # 将 'Model' 索引层转换为列

# 为了更好的可读性，交换列的层级，让模型在最上层
performance_pivot = performance_pivot.swaplevel(0, 1, axis=1)

# 按模型名称对列进行排序，使输出更整洁
performance_pivot.sort_index(axis=1, level=0, inplace=True)


print(performance_pivot.to_string(float_format="%.4f"))
